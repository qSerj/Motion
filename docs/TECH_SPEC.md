# Motion Trainer AI — Техническое задание и документация (актуальное состояние)

> Цель документа: зафиксировать текущее состояние проекта, форматы взаимодействия и будущие требования к развитию платформы. Документ написан «от кода», но ориентирован на дальнейшее проектирование и развитие.

## 1. Назначение и цели проекта

**Motion Trainer AI** — интерактивная платформа для геймификации спорта/танцев/ЛФК с использованием компьютерного зрения. Основные цели:

- Превратить тренировку в игру с обратной связью в реальном времени.
- Дать возможность разучивания движений с контролем точности.
- Поддержать режимы на 1+ игроков.
- Предоставить инфраструктуру для создания контента (уровней/пакетов).

## 2. Термины и определения

- **Скелет/landmarks** — набор ключевых точек тела (MediaPipe Pose) в координатах 3D (world landmarks).
- **Партитура/паттерн** — эталон движения, сохраненный как таймлайн углов/координат в JSON.
- **IPC** — межпроцессное взаимодействие между Python (backend) и C# (frontend) через ZeroMQ/NetMQ.
- **Мета** — JSON-метаданные кадра (очки, статус, время).
- **MTP** — контейнер контента (ZIP с расширением `.mtp`), описывающий уровень.

## 3. Архитектура решения (как реализовано сейчас)

### 3.1 Компоненты

**Backend (Python 3.11, headless)**
- Библиотеки: `mediapipe`, `opencv-python`, `numpy`, `pyzmq`, опционально `ffpyplayer`.
- Функции:
  - Детекция позы, получение 3D landmarks.
  - Подготовка двух видеопотоков (референс + пользователь) и отрисовка скелета на пользовательском кадре.
  - Публикация кадров и метаданных (включая активные оверлеи и прогресс оцифровки) через ZeroMQ (PUB).
  - Обработка команд управления через ZeroMQ (REP).
  - Оцифровка видео в MTP v2 (`manifest.json` + `patterns.json` + `video.mp4`).

**Frontend (C# .NET, Avalonia)**
- Библиотеки: `Avalonia`, `NetMQ`.
- Функции:
  - Подключение к PUB-сокету backend (SUB).
  - Получение двух кадров (референс и пользователь) и метаданных.
  - Отображение кадров и статуса в UI.
  - Отправка команд (load/pause/resume/restart/seek/get_state/digitize).

### 3.2 Поток данных (текущая реализация)

1. Frontend отправляет команду `load`, передавая пути к видео и паттерну (из .mtp).
2. Backend читает:
   - видео-референс;
   - вебкамеру пользователя.
3. Для каждого кадра:
   - строит скелет пользователя;
   - накладывает скелет на кадр пользователя;
   - обновляет метаданные (статус/счет/время/оверлеи/прогресс);
   - отправляет **две** JPEG-картинки (референс + пользователь) и JSON-метаданные в ZeroMQ PUB.
4. Frontend:
   - подписывается на тему `video`;
   - принимает метаданные и оба изображения;
   - обновляет UI и активные оверлеи.

## 4. Формат IPC (Backend ↔ Frontend)

### 4.1 Транспорт
- **Видео**: ZeroMQ PUB/SUB.
  - **Backend**: `bind` на `tcp://127.0.0.1:5555`.
  - **Frontend**: `connect` на `tcp://127.0.0.1:5555`.
- **Команды**: ZeroMQ REP/REQ.
  - **Backend**: `bind` на `tcp://127.0.0.1:5556`.
  - **Frontend**: `connect` на `tcp://127.0.0.1:5556`.

### 4.2 Формат сообщения (multipart)
Сообщение состоит из 4 частей:

1. **Topic**: строка `video`.
2. **Metadata JSON**: строка JSON, пример:

```json
{
  "state": "PLAYING",
  "score": 120,
  "time": 12.3,
  "status": "",
  "progress": 0,
  "overlays": []
}
```

3. **Reference image bytes**: JPEG-байты референса.
4. **User image bytes**: JPEG-байты пользователя.

### 4.3 Контракт метаданных
| Поле | Тип | Описание | Источник |
|---|---|---|---|
| `state` | string | Текущее состояние (`IDLE/PLAYING/PAUSED/FINISHED/PROCESSING`) | Backend |
| `score` | int | Текущий счет | Backend |
| `status` | string | Статус/сообщение | Backend |
| `time` | float | Текущее время в секундах | Backend |
| `progress` | int | Прогресс оцифровки (0-100) | Backend |
| `overlays` | array | Активные события из `timeline.json` | Backend |

Frontend десериализует JSON в `GameData`.

### 4.4 Частота кадров
- Backend ограничивает FPS через `target_delay`, зависящий от FPS референсного видео.
- Изображение кодируется в JPEG (`quality=50`), чтобы снизить нагрузку на IPC.

### 4.5 Команды управления (REQ/REP)

**Команды (JSON):**

```json
{ "type": "load", "video_path": "...", "json_path": "...", "timeline_path": "..." }
```

```json
{ "type": "pause" }
```

```json
{ "type": "resume" }
```

```json
{ "type": "restart" }
```

```json
{ "type": "seek", "time": 12.5 }
```

```json
{ "type": "get_state" }
```

```json
{ "type": "digitize", "source_path": "...", "output_path": "..." }
```

```json
{ "type": "stop" }
```

**Ответ:** `{"status":"ok"}` либо `{"status":"error","msg":"..."}`.
Для `get_state` ответ включает поля `state` и `level` (пути к текущим ресурсам).

## 5. Форматы данных (детально)

### 5.1 Партитура движений (JSON)
Файл-результат `VideoDigitizer`, пример структуры:

```json
[
  {
    "timestamp": 0.0,
    "angles": {
      "left_elbow": 143.2,
      "right_elbow": 128.7
    }
  },
  {
    "timestamp": 0.033,
    "angles": {
      "left_elbow": 145.1,
      "right_elbow": 129.0
    }
  }
]
```

**Примечания:**
- `timestamp` = `frame_count / fps`.
- Сейчас учитываются только локти (см. TODO в коде).

### 5.2 Контейнер `.mtp` (проектный формат)
**Статус**: реализован MTP v2 для базового кейса (video + patterns).

Актуальная структура (ZIP, минимальный пакет от digitizer):
```
<package>.mtp/
  manifest.json
  patterns.json
  video.mp4
  timeline.json    (опционально)
  assets/          (опционально, для пользовательских пакетов)
```

**Назначение файлов:**
- `manifest.json`: метаданные уровня и карта файлов (ключи `video`, `patterns`, `timeline`).
- `patterns.json`: эталоны движений (JSON).
- `video.mp4`: референсное видео.
- `timeline.json`: сценарий уровней (ивенты/подсказки/триггеры, не исполняется).

## 6. Backend (Python) — состав и зоны ответственности

### 6.1 Модули
- `backend/core/pose_engine.py`
  - Обертка над MediaPipe Pose.
  - `process_frame` → `results`.
  - `get_3d_landmarks` → словарь `id -> [x,y,z]`.
- `backend/core/geometry.py`
  - `calculate_angle_3d`, `calculate_distance`.
- `backend/core/game_engine.py`
  - Основной игровой цикл.
  - IPC PUB/REP, подготовка кадров и метаданных.
- `backend/core/digitizer.py`
  - `VideoDigitizer` — создание MTP v2 (manifest + patterns + video) без `timeline.json`.
- `backend/processors/video_processor.py`
  - Legacy `VideoDigitizer` — генерация JSON без упаковки.
- `backend/play_game.py`
  - Точка запуска игры (ожидает команды `load`).

### 6.2 Сценарии запуска

**Оцифровка видео (MTP v2)**
1. Отправить команду `digitize` на порт `5556` (frontend делает это автоматически при вызове).
2. Backend создаст `.mtp` архив с `manifest.json`, `patterns.json`, `video.mp4`.

**Запуск игры (backend only)**
1. Запустить backend:

```bash
python backend/play_game.py
```

### 6.3 Логика оценки (текущая)
- В игровом цикле выполняется трекинг позы и отрисовка скелета.
- Сравнение углов и скоринг временно отключены (статус отправляется пустой строкой, счет не изменяется).

## 7. Frontend (C# / Avalonia) — состав и зоны ответственности

### 7.1 Модули
- `MainWindowViewModel`:
  - Подписка на ZeroMQ (NetMQ) и прием кадров.
  - Обновление `ReferenceFrame`, `UserFrame`, `Score`, `GameStatus`, `StatusColor`.
  - Отправка команд через REQ.
  - Заполнение списка активных оверлеев из метаданных.
- `MtpFileService`:
  - Чтение `manifest.json` и извлечение ресурсов во временную папку.
- `GameData`:
  - Модель данных, соответствующая JSON метаданным из backend.

### 7.2 Поток UI-обновления
- Сокет читается в фоновом потоке.
- Для обновления UI используется `Dispatcher.UIThread.Post`.

## 8. Требования к будущему развитию (цели и ограничения)

### 8.1 Контейнеризация уровней (.mtp)
- Требуется слой загрузки и упаковки `.mtp`.
- Должна быть валидация структуры (наличие `manifest.json`, `timeline.json`).
- Желательно обеспечить обратную совместимость через `manifest.version`.

### 8.2 Редактор уровней
- Нужен визуальный редактор таймлайна.
- Экспорт паттерна в `patterns/*.json`.
- Связь видео/аудио с событиями.

### 8.3 Расширение скоринга
- Поддержка большего числа суставов (колени, плечи, корпус).
- Кастомные триггеры (прыжок, присед, касание).
- Метрики: средняя точность, серии попаданий, рейтинг.

### 8.4 Многопользовательский режим
- Распознавание нескольких скелетов.
- Привязка скелета к игроку (tracking ID).
- Отдельный скоринг и UI-панели.

## 9. Требования к качеству и производительности

- Минимальная задержка между кадром и отображением UI.
- Предсказуемая частота кадров (ограничение CPU/GPU).
- Возможность запуска на потребительских ноутбуках.

## 10. Открытые вопросы

- Исполнение событий `timeline.json` в рантайме.
- Синхронизация аудио при замедлении (`speed` != 1.0).
- Расширение JSON-структуры паттернов (углы, позы, траектории).
- Нужен ли режим передачи «сырых» landmarks в UI (для кастомного рендера).

## 11. Источники истины (текущая реализация)

- Backend IPC и логика `GameEngine`: `backend/core/game_engine.py`.
- Формат метаданных: `frontend/Motion.Desktop/Models/GameData.cs`.
- Подписка на ZMQ: `frontend/Motion.Desktop/ViewModels/MainWindowViewModel.cs`.
- Оцифровка MTP v2: `backend/core/digitizer.py`.
