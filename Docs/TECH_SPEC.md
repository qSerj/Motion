# Motion Trainer AI — Техническое задание и документация (черновик)

> Цель документа: зафиксировать текущее состояние проекта, форматы взаимодействия и будущие требования к развитию платформы. Документ написан «от кода», но ориентирован на дальнейшее проектирование и развитие.

## 1. Назначение и цели проекта

**Motion Trainer AI** — интерактивная платформа для геймификации спорта/танцев/ЛФК с использованием компьютерного зрения. Основные цели:

- Превратить тренировку в игру с обратной связью в реальном времени.
- Дать возможность разучивания движений с контролем точности.
- Поддержать режимы на 1+ игроков.
- Предоставить инфраструктуру для создания контента (уровней/пакетов).

## 2. Термины и определения

- **Скелет/landmarks** — набор ключевых точек тела (MediaPipe Pose) в координатах 3D (world landmarks).
- **Партитура/паттерн** — эталон движения, сохраненный как таймлайн углов/координат в JSON.
- **IPC** — межпроцессное взаимодействие между Python (backend) и C# (frontend) через ZeroMQ/NetMQ.
- **Мета** — JSON-метаданные кадра (очки, статус, время).
- **MTP** — контейнер контента (ZIP с расширением `.mtp`), описывающий уровень.

## 3. Архитектура решения (как реализовано сейчас)

### 3.1 Компоненты

**Backend (Python 3.11, headless)**
- Библиотеки: `mediapipe`, `opencv-python`, `numpy`, `pyzmq`, опционально `ffpyplayer`.
- Функции:
  - Детекция позы, получение 3D landmarks.
  - Сравнение углов эталона и пользователя.
  - Формирование видеопотока (склейка референса и камеры).
  - Публикация кадра и метаданных через ZeroMQ (PUB).

**Frontend (C# .NET, Avalonia)**
- Библиотеки: `Avalonia`, `NetMQ`.
- Функции:
  - Подключение к PUB-сокету backend (SUB).
  - Получение кадра и метаданных.
  - Отображение текущего кадра и статуса в UI.

### 3.2 Поток данных (текущая реализация)

1. Backend читает:
   - видео-референс (танец/упражнение);
   - вебкамеру пользователя.
2. Для каждого кадра:
   - строит скелет пользователя;
   - вычисляет углы (например локти);
   - сравнивает с эталоном на текущий таймштамп;
   - формирует статус (PERFECT/GOOD/MISS) и счет;
   - склеивает референс + пользовательский кадр в один кадр;
   - отправляет JPEG + метаданные в ZeroMQ PUB.
3. Frontend:
   - подписывается на тему `video`;
   - принимает метаданные и изображение;
   - обновляет UI.

## 4. Формат IPC (Backend ↔ Frontend)

### 4.1 Транспорт
- ZeroMQ PUB/SUB.
- **Backend**: `bind` на `tcp://127.0.0.1:5555`.
- **Frontend**: `connect` на `tcp://127.0.0.1:5555`.

### 4.2 Формат сообщения (multipart)
Сообщение состоит из 3 частей:

1. **Topic**: строка `video`.
2. **Metadata JSON**: строка JSON, пример:

```json
{
  "score": 120,
  "status": "PERFECT!",
  "time": 12.3
}
```

3. **Image bytes**: JPEG-байты.

### 4.3 Контракт метаданных
| Поле | Тип | Описание | Источник |
|---|---|---|---|
| `score` | int | Текущий счет | Backend (`GameEngine`) |
| `status` | string | Статус попадания (`PERFECT!`, `GOOD`, `MISS`) | Backend |
| `time` | float | Текущее время в секундах | Backend |

Frontend десериализует JSON в `GameData`.

### 4.4 Частота кадров
- Backend ограничивает FPS через `target_delay`, зависящий от FPS референсного видео и `speed`.
- Изображение кодируется в JPEG (`quality=70`), чтобы снизить нагрузку на IPC.

## 5. Форматы данных (детально)

### 5.1 Партитура движений (JSON)
Файл-результат `VideoDigitizer`, пример структуры:

```json
[
  {
    "timestamp": 0.0,
    "angles": {
      "left_elbow": 143.2,
      "right_elbow": 128.7
    }
  },
  {
    "timestamp": 0.033,
    "angles": {
      "left_elbow": 145.1,
      "right_elbow": 129.0
    }
  }
]
```

**Примечания:**
- `timestamp` = `frame_count / fps`.
- Сейчас учитываются только локти (см. TODO в коде).

### 5.2 Контейнер `.mtp` (проектный формат)
**Статус**: формат описан концептуально, еще не реализован.

Предлагаемая структура (ZIP):
```
<package>.mtp/
  manifest.json
  timeline.json
  assets/
  patterns/
```

**Назначение файлов:**
- `manifest.json`: метаданные уровня (название, автор, сложность, режимы, требуемые ассеты).
- `timeline.json`: сценарий уровней (ивенты/подсказки/триггеры).
- `assets/`: видео/аудио/изображения.
- `patterns/`: эталоны движений (JSON).

## 6. Backend (Python) — состав и зоны ответственности

### 6.1 Модули
- `backend/core/pose_engine.py`
  - Обертка над MediaPipe Pose.
  - `process_frame` → `results`.
  - `get_3d_landmarks` → словарь `id -> [x,y,z]`.
- `backend/core/geometry.py`
  - `calculate_angle_3d`, `calculate_distance`.
- `backend/core/game_engine.py`
  - Основной игровой цикл.
  - IPC pub, подготовка кадров и метаданных.
- `backend/processors/video_processor.py`
  - `VideoDigitizer` — построение партитуры из видео.
- `backend/play_game.py`
  - Точка запуска игры (читает JSON + видео).

### 6.2 Сценарии запуска

**Оцифровка видео**
1. Задать `VIDEO_FILE` и `OUTPUT_FILE` в `backend/main_digitizer.py`.
2. Запустить:

```bash
python backend/main_digitizer.py
```

**Запуск игры (backend only)**
1. Убедиться, что существуют `backend/data/dance_data.json` и `backend/data/dance_video.mp4`.
2. Запустить:

```bash
python backend/play_game.py
```

### 6.3 Логика оценки (текущая)
- Вычисляются углы локтей для пользователя.
- Берутся эталонные углы из `pattern_map` по текущему `timestamp` (округление до 0.1 сек).
- Диапазоны точности:
  - `PERFECT!` — оба локтя в пределах `tolerance`.
  - `GOOD` — оба локтя в пределах `tolerance * 1.5`.
  - иначе `MISS`.

## 7. Frontend (C# / Avalonia) — состав и зоны ответственности

### 7.1 Модули
- `MainWindowViewModel`:
  - Подписка на ZeroMQ (NetMQ) и прием кадров.
  - Обновление `CurrentFrame`, `Score`, `GameStatus`, `StatusColor`.
- `GameData`:
  - Модель данных, соответствующая JSON метаданным из backend.

### 7.2 Поток UI-обновления
- Сокет читается в фоновом потоке.
- Для обновления UI используется `Dispatcher.UIThread.Post`.

## 8. Требования к будущему развитию (цели и ограничения)

### 8.1 Контейнеризация уровней (.mtp)
- Требуется слой загрузки и упаковки `.mtp`.
- Должна быть валидация структуры (наличие `manifest.json`, `timeline.json`).
- Желательно обеспечить обратную совместимость через `manifest.version`.

### 8.2 Редактор уровней
- Нужен визуальный редактор таймлайна.
- Экспорт паттерна в `patterns/*.json`.
- Связь видео/аудио с событиями.

### 8.3 Расширение скоринга
- Поддержка большего числа суставов (колени, плечи, корпус).
- Кастомные триггеры (прыжок, присед, касание).
- Метрики: средняя точность, серии попаданий, рейтинг.

### 8.4 Многопользовательский режим
- Распознавание нескольких скелетов.
- Привязка скелета к игроку (tracking ID).
- Отдельный скоринг и UI-панели.

## 9. Требования к качеству и производительности

- Минимальная задержка между кадром и отображением UI.
- Предсказуемая частота кадров (ограничение CPU/GPU).
- Возможность запуска на потребительских ноутбуках.

## 10. Открытые вопросы

- Полная спецификация `timeline.json` (формат еще не реализован).
- Синхронизация аудио при замедлении (`speed` != 1.0).
- Расширение JSON-структуры паттернов (углы, позы, траектории).
- Нужен ли режим передачи «сырых» landmarks в UI (для кастомного рендера).

## 11. Источники истины (текущая реализация)

- Backend IPC и логика `GameEngine`: `backend/core/game_engine.py`.
- Формат метаданных: `frontend/Motion.Desktop/Models/GameData.cs`.
- Подписка на ZMQ: `frontend/Motion.Desktop/ViewModels/MainWindowViewModel.cs`.
- Оцифровка паттерна: `backend/processors/video_processor.py`.
